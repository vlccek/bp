    @ARTICLE{knn,
    AUTHOR = {Peterson, L. E.},
    TITLE   = {{K}-nearest neighbor},
    YEAR    = {2009},
    JOURNAL = {Scholarpedia},
    VOLUME  = {4},
    NUMBER  = {2},
    PAGES   = {1883},
    DOI     = {10.4249/scholarpedia.1883},
    NOTE    = {revision \#137311}
    }

    @article{octreehash,
    author = {Drost, Bertram and Ilic, Slobodan},
    year = {2018},
    month = {02},
    pages = {1-13},
    title = {Almost constant-time 3D nearest-neighbor lookup using implicit octrees},
    volume = {29},
    journal = {Machine Vision and Applications},
    doi = {10.1007/s00138-017-0889-4}
    }


@ARTICLE{HWhash,
  author={Fairouz, Abbas A. and Abusultan, Monther and Fedorov, Viacheslav V. and Khatri, Sunil P.},
  journal={IEEE Transactions on Computers}, 
  title={Hardware Acceleration of Hash Operations in Modern Microprocessors}, 
  year={2021},
  volume={70},
  number={9},
  pages={1412-1426},
  keywords={Microprocessors;Hardware;Hafnium;Microarchitecture;Indexes;Circuit synthesis;Memory modules;Special function unit (SFU);hashing;hardware hash unit;modern microprocessors;hash table;hash function;content-addressable memory (CAM)},
  doi={10.1109/TC.2020.3010855}}

@book{KnuthDonaldErvin1998Taoc,
publisher = {Addison-Wesley},
isbn = {0-201-89685-0},
year = {1998},
title = {The art of computer programming / Vol. 3, Sorting and serching},
edition = {3rd ed.},
language = {eng},
address = {Upper Saddle River},
author = {Knuth, Donald Ervin},
keywords = {programování vt; výpočetní technika vt; algoritmy; elektronické digitální počítače},
}

@Article{hashtablebench,
AUTHOR = {Tapia-Fernández, Santiago and García-García, Daniel and García-Hernandez, Pablo},
TITLE = {Key Concepts, Weakness and Benchmark on Hash Table Data Structures},
JOURNAL = {Algorithms},
VOLUME = {15},
YEAR = {2022},
NUMBER = {3},
ARTICLE-NUMBER = {100},
URL = {https://www.mdpi.com/1999-4893/15/3/100},
ISSN = {1999-4893},
ABSTRACT = {Most computer programs or applications need fast data structures. The performance of a data structure is necessarily influenced by the complexity of its common operations; thus, any data-structure that exhibits a theoretical complexity of amortized constant time in several of its main operations should draw a lot of attention. Such is the case of a family of data structures that is called hash tables. However, what is the real efficiency of these hash tables? That is an interesting question with no simple answer and there are some issues to be considered. Of course, there is not a unique hash table; in fact, there are several sub-groups of hash tables, and, even more, not all programming languages use the same variety of hash tables in their default hash table implementation, neither they have the same interface. Nevertheless, all hash tables do have a common issue: they have to solve hash collisions; that is a potential weakness and it also induces a classification of hash tables according to the strategy to solve collisions. In this paper, some key concepts about hash tables are exposed and some definitions about those key concepts are reviewed and clarified, especially in order to study the characteristics of the main strategies to implement hash tables and how they deal with hash collisions. Then, some benchmark cases are designed and presented to assess the performance of hash tables. The cases have been designed to be randomized, to be self-tested, to be representative of a real user cases, and to expose and analyze the impact of different factors over the performance across different hash tables and programming languages. Then, all cases have been programmed using C++, Java and Python and analyzed in terms of interfaces and efficiency (time and memory). The benchmark yields important results about the performance of these structures and its (lack of) relationship with complexity analysis.},
DOI = {10.3390/a15030100}
}


@article{balltree,
  title={Ball*-tree: Efficient spatial indexing for constrained nearest-neighbor search in metric spaces},
  author={Mohamad Dolatshah and Ali Hadian and Behrouz Minaei-Bidgoli},
  journal={ArXiv},
  year={2015},
  volume={abs/1511.00628},
  url={https://api.semanticscholar.org/CorpusID:14162909}
}


% technical report
@techreport{balltreefive,
  title={Five balltree construction algorithms},
  author={Omohundro, Stephen M},
  year={1989},
  publisher={International Computer Science Institute Berkeley}
}


@article{knn-survey,
  title={Survey of nearest neighbor techniques},
  author={Bhatia, Nitin and others},
  journal={arXiv preprint arXiv:1007.0085},
  year={2010}
}


@phdthesis{moore1991kdtrees,
  author = {Moore, Andrew W.},
  title = {An Introductory Tutorial on Kd-Trees},
  school = {Carnegie Mellon University},
  year = {1991},
  type = {PhD Thesis},
  number = {Technical Report No. 209},
  address = {Computer Laboratory, University of Cambridge},
  note = {Extract from Andrew Moore's PhD Thesis: Efficient Memory-based Learning for Robot Control}
}


@article{originBalltree,
  author  = {Ting Liu and Andrew W. Moore and Alexander Gray},
  title   = {New Algorithms for Efficient High-Dimensional Nonparametric Classification},
  journal = {Journal of Machine Learning Research},
  year    = {2006},
  volume  = {7},
  number  = {41},
  pages   = {1135-1158},
  url     = {http://jmlr.org/papers/v7/liu06a.html}
}

@article{kdimensiontree,
  title={An algorithm for finding best matches in logarithmic expected time},
  author={Friedman, Jerome H and Bentley, Jon Louis and Finkel, Raphael Ari},
  journal={ACM Transactions on Mathematical Software (TOMS)},
  volume={3},
  number={3},
  pages={209--226},
  year={1977},
  publisher={ACM New York, NY, USA}
}

@article{reviewNN,
  title={A review of various k-nearest neighbor query processing techniques},
  author={Dhanabal, Subramaniam and Chandramathi, SJIJCA},
  journal={International Journal of Computer Applications},
  volume={31},
  number={7},
  pages={14--22},
  year={2011},
  publisher={Citeseer}
}


% GJK

@INPROCEEDINGS{minikowski,
  author={Barki, Hichem and Denis, Florence and Dupont, Florent},
  booktitle={2010 Shape Modeling International Conference}, 
  title={A New Algorithm for the Computation of the Minkowski Difference of Convex Polyhedra}, 
  year={2010},
  volume={},
  number={},
  pages={206-210},
  keywords={Computer aided manufacturing;Difference equations;Shape;Laboratories;Reflection;Computational geometry;Libraries;Application software;Robot motion;Motion planning;contributing vertices;Minkowski difference;Minkowski sum;Nef polyhedra},
  doi={10.1109/SMI.2010.12}}


@ARTICLE{initialGJK,
  author={Gilbert, E.G. and Johnson, D.W. and Keerthi, S.S.},
  journal={IEEE Journal on Robotics and Automation}, 
  title={A fast procedure for computing the distance between complex objects in three-dimensional space}, 
  year={1988},
  volume={4},
  number={2},
  pages={193-203},
  keywords={Iterative algorithms;Euclidean distance;Orbital robotics;Algorithm design and analysis;Computational efficiency;Linear approximation;Application software;Computer graphics;Mathematical model;Length measurement},
  doi={10.1109/56.2083}}


@article{3D_colision_survey,
    title = {3D collision detection: a survey},
    journal = {Computers \& Graphics},
    volume = {25},
    number = {2},
    pages = {269-285},
    year = {2001},
    issn = {0097-8493},
    doi = {https://doi.org/10.1016/S0097-8493(00)00130-8},
    url = {https://www.sciencedirect.com/science/article/pii/S0097849300001308},
    author = {P. Jiménez and F. Thomas and C. Torras},
    keywords = {Geometric algorithms, Languages and systems, Collision detection, Interference tests},
    abstract = {Many applications in Computer Graphics require fast and robust 3D collision detection algorithms. These algorithms can be grouped into four approaches: space–time volume intersection, swept volume interference, multiple interference detection and trajectory parameterization. While some approaches are linked to a particular object representation scheme (e.g., space–time volume intersection is particularly suited to a CSG representation), others do not. The multiple interference detection approach has been the most widely used under a variety of sampling strategies, reducing the collision detection problem to multiple calls to static interference tests. In most cases, these tests boil down to detecting intersections between simple geometric entities, such as spheres, boxes aligned with the coordinate axes, or polygons and segments. The computational cost of a collision detection algorithm depends not only on the complexity of the basic interference test used, but also on the number of times this test is applied. Therefore, it is crucial to apply this test only at those instants and places where a collision can truly occur. Several strategies have been developed to this end: (1) to find a lower time bound for the first collision, (2) to reduce the pairs of primitives within objects susceptible of interfering, and (3) to cut down the number of object pairs to be considered for interference. These strategies rely on distance computation algorithms, hierarchical object representations, orientation-based pruning criteria, and space partitioning schemes. This paper tries to provide a comprehensive survey of all these techniques from a unified viewpoint, so that well-known algorithms are presented as particular instances of general approaches.}
    }

% AVX

@manual{ARM_Neon,
  author       = {Arm Limited},
  title        = {Neon},
  year         = 2024,
  url          = {https://developer.arm.com/Architectures/Neon},
  urldate      = {2024-04-10},
  organization = {Arm Developer},
  note         = {Accessed on 2024-04-10}
}


@manual{ARM_helium,
  author       = {Arm Limited},
  title        = {Helium},
  year         = 2024,
  url          = {https://developer.arm.com/Architectures/Helium},
  urldate      = {2024-04-10},
  organization = {Arm Developer},
  note         = {Accessed on 2024-04-10}
}



@manual{ARM_SVE,
  author       = {Arm Limited},
  title        = {SVE},
  year         = 2024,
  url          = {https://developer.arm.com/Architectures/Scalable%20Vector%20Extensions},
  urldate      = {2024-04-10},
  organization = {Arm Developer},
  note         = {Accessed on 2024-04-10}
}


@manual{gcc_tree_ssa_vectorization,
  title = {GCC Tree SSA Vectorization},
  url = {https://gcc.gnu.org/projects/tree-ssa/vectorization.html},
  author = {GCC Team},
  year = {2024},
  publisher = {GNU},
}


@manual{gcc_vector,
  title = {Using Vector Instructions through Built-in Functions},
  url = {https://gcc.gnu.org/onlinedocs/gcc/Vector-Extensions.html},
  author = {GCC Team},
  year = {2024},
  publisher = {GNU},
}


@manual{intel2023autovectorization,
  title        = {Compiler Auto-Vectorization Guide},
  author       = {{Intel Corporation}},
  year         = 2023,
  url          = {https://www.intel.com/content/dam/develop/external/us/en/documents/31848-compilerautovectorizationguide.pdf},
  organization = {Intel Corporation},
  note         = {PDF document}
}

\dsads

@article{voro,
    author = {Rycroft, Chris H.},
    title = "{VORO++: A three-dimensional Voronoi cell library in C++}",
    journal = {Chaos: An Interdisciplinary Journal of Nonlinear Science},
    volume = {19},
    number = {4},
    pages = {041111},
    year = {2009},
    month = {10},
    abstract = "{VORO++1,2 is an open source software library for the computation of the Voronoi tessellation, originally proposed by Georgy Voronoi in 1907. For a set of points in a domain, the tessellation is defined by associating a cell of space to each point that is closer to that point than any other. It has applications in many fields, and in physics and materials science it has been used extensively in the analysis of particle systems, for tracking changes in density, or for examining local neighbor relationships. While other mature software libraries exist (particularly QHULL, used by MATLAB), VORO++ has been designed specifically for handling large-scale three-dimensional research problems where flexibility is required. It is structured around several C++ classes and is designed to be easily modified and incorporated into other programs. It employs a direct method of calculation whereby each cell is computed individually—this perspective is useful in many physical applications which often rely on cell-based statistics, and it allows the computation of individual cells to be tailored to account for walls and other complex boundary conditions. Plane wall surfaces can be computed exactly (Fig. 1), while curved surfaces (Figs. 2 and 3) can be well-approximated. The code deals with truncation errors in floating point arithmetic, and can natively handle degenerate cases where Voronoi cells with high-order vertices may form. Neighbor calculations and tessellations for polydisperse particle packings (Fig. 4) are also supported. Since each cell is computed individually, it is straightforward to generalize to a multicore architecture and achieve very high parallel efficiency.}",
    issn = {1054-1500},
    doi = {10.1063/1.3215722},
    url = {https://doi.org/10.1063/1.3215722},
    eprint = {https://pubs.aip.org/aip/cha/article-pdf/doi/10.1063/1.3215722/13277008/041111\_1\_online.pdf},
}


@article{voro_para,
title = {An extension to Voro++ for multithreaded computation of Voronoi cells},
journal = {Computer Physics Communications},
volume = {291},
pages = {108832},
year = {2023},
issn = {0010-4655},
doi = {https://doi.org/10.1016/j.cpc.2023.108832},
url = {https://www.sciencedirect.com/science/article/pii/S0010465523001777},
author = {Jiayin Lu and Emanuel A. Lazar and Chris H. Rycroft},
keywords = {Voronoi tessellation, Computational geometry, Multi-threaded programming},
abstract = {Voro++ is a software library written in C++ for computing the Voronoi tessellation, a technique in computational geometry that is widely used for analyzing systems of particles. Voro++ was released in 2009 and is based on computing the Voronoi cell for each particle individually. Here, we take advantage of modern computer hardware, and extend the original serial version to allow for multithreaded computation of Voronoi cells via the OpenMP application programming interface. We test the performance of the code, and demonstrate that it can achieve parallel efficiencies greater than 95% in many cases. The multithreaded extension follows standard OpenMP programming paradigms, allowing it to be incorporated into other programs. We provide an example of this using the VoroTop software library, performing a multithreaded Voronoi cell topology analysis of up to 102.4 million particles.
Program summary
Program title: Voro++ CPC Library link to program files: https://doi.org/10.17632/tddc4w4zkk.1 Developer's repository link: https://github.com/chr1shr/voro Licensing provisions: BSD 3-clause (with LBNL modification) Programming language: C++ External routines/libraries: OpenMP Nature of problem: Multithreaded computation of the Voronoi tessellation in two and three dimensions Solution method: The Voro++ library is built around several C++ classes that can be incorporated into other programs. The two largest components are the container... classes that spatially sort input particles into a grid-based data structure, allowing for efficient searches of nearby particles, and the voronoicell... classes that represent a single Voronoi cell as an arbitrary convex polygon or polyhedron. The Voronoi cell for each particle is built by considering a sequence of plane cuts based on neighboring particles, after which many different statistics (e.g. volume, centroid, number of vertices) can be computed. Since each Voronoi cell is calculated individually, the Voronoi cells can be computed using multithreading via OpenMP.}
}



